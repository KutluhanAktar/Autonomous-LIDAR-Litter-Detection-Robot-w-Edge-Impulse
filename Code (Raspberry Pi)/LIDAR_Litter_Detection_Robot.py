# LIDAR Litter Detection Robot w/ Edge Impulse

# Raspberry Pi 4

# By Kutluhan Aktar

# Recognize and monitor litter with object detection via this self-driving robot.
# It also deploys a video stream and a fall detection system.

# For more information:
# https://www.theamplituhedron.com/projects/Autonomous_(LIDAR)_Litter_Detection_Robot_w_Edge_Impulse/

from adafruit_rplidar import RPLidar
from math import floor
import RPi.GPIO as GPIO
from time import sleep

# Create the Litter Detection Robot class with the required settings:
class Litter_Detection_Robot:
    def __init__(self, mot_pin_1, mot_pin_2, mot_pin_3, mot_pin_4, mot_pin_5, mot_pin_6):
        # Setup the RPLidar:
        PORT_NAME = '/dev/ttyUSB0'
        self.lidar = RPLidar(None, PORT_NAME, timeout=30)
        self.con_scan = True
        # Define the L298N motor driver board pins:
        self.in_1_1 = mot_pin_1
        self.in_1_2 = mot_pin_2
        self.en_1 = mot_pin_3
        self.in_2_1 = mot_pin_4
        self.in_2_2 = mot_pin_5
        self.en_2 = mot_pin_6
        # Set GPIO mode:
        GPIO.setmode(GPIO.BCM)
    # Get information from the RPLidar:
    def get_data_from_LIDAR(self):
        # Record the data generated by the RPLidar.
        if(self.con_scan):
            try:
                print(self.lidar.info)
                for scan in self.lidar.iter_scans():
                    self.scan_data = [0]*360
                    for (_, angle, distance) in scan:
                        self.scan_data[min([359, floor(angle)])] = distance
                    self.process_lidar_data(60, 120, 240, 300, 340, 20)
            except KeyboardInterrupt:
                self.con_scan = False
                print("\nLIDAR Stopped!")
                self.lidar.stop()
                self.lidar.disconnect()
                GPIO.cleanup()
    # Process the data generated by the RPLidar to control the robot chassis.
    def process_lidar_data(self, r_ang_s, r_ang_e, l_ang_s, l_ang_e, f_ang_s, f_ang_e, t=400, _range=16):
        # Object Distance:
        r_start = r_end = l_start = l_end = f_start = f_end = 3000
        # Debugging the data generated by the RPLidar:
        for i in range(_range):
            _angle = r_ang_s + i
            if(self.scan_data[_angle] > 1):
                r_start = self.scan_data[_angle]
                #print("Right Dis. Start = " + str(r_start))
                break
        for i in range(_range):
            _angle = r_ang_e - i
            if(self.scan_data[_angle] > 1):
                r_end = self.scan_data[_angle]
                #print("Right Dis. End = " + str(r_end))
                break
            
        for i in range(_range):
            _angle = l_ang_s + i
            if(self.scan_data[_angle] > 1):
                l_start = self.scan_data[_angle]
                #print("Left Dis. Start = " + str(l_start))
                break
        for i in range(_range):
            _angle = l_ang_e - i
            if(self.scan_data[_angle] > 1):
                l_end = self.scan_data[_angle]
                #print("Left Dis. End = " + str(l_end))
                break

        for i in range(_range):
            _angle = f_ang_s + i
            if(self.scan_data[_angle] > 1):
                f_start = self.scan_data[_angle]
                #print("Front Dis. Start = " + str(f_start))
                break
        for i in range(_range):
            _angle = f_ang_e - i
            if(self.scan_data[_angle] > 1):
                f_end = self.scan_data[_angle]
                #print("Front Dis. End = " + str(f_end))
                break
            
        # Control the robot chassis according to the debugged distance values:
        if((r_start < t) and (r_end < t)):
            print("\nStop!")
            self.robot_chassis_controls("stop")
            sleep(0.5)
            print("Right!")
            self.robot_chassis_controls("left", speed="moderate")
            sleep(1)
            print("Go!")
            self.robot_chassis_controls("forward", speed="low")
        if((l_start < t) and (l_end < t)):
            print("\nStop!")
            self.robot_chassis_controls("stop")
            sleep(0.5)
            print("Left!")
            self.robot_chassis_controls("right", speed="moderate")
            sleep(1)
            print("Go!")
            self.robot_chassis_controls("forward", speed="low")
        if((f_start < t) and (f_end < t)):
            print("\nStop!")
            self.robot_chassis_controls("stop")
            sleep(0.5)
            print("Front!")
            self.robot_chassis_controls("turn", speed="moderate")
            sleep(1)
            print("Go!")
            self.robot_chassis_controls("forward", speed="low")
            

    # Initiate the robot chassis:
    def robot_chassis_init(self):
        # Define the motor driver pin settings:
        GPIO.setup(self.in_1_1, GPIO.OUT)
        GPIO.setup(self.in_1_2, GPIO.OUT)
        GPIO.setup(self.en_1, GPIO.OUT)
        GPIO.setup(self.in_2_1, GPIO.OUT)
        GPIO.setup(self.in_2_2, GPIO.OUT)
        GPIO.setup(self.en_2, GPIO.OUT)
        # Default:
        GPIO.output(self.in_1_1, GPIO.HIGH)
        GPIO.output(self.in_1_2, GPIO.LOW)
        GPIO.output(self.in_2_1, GPIO.HIGH)
        GPIO.output(self.in_2_2, GPIO.LOW)
        self.s_1 = GPIO.PWM(self.en_1, 100)
        self.s_1.start(25)
        self.s_2 = GPIO.PWM(self.en_2, 100)
        self.s_2.start(25)
    # Control the robot chassis: 
    def robot_chassis_controls(self, command, speed="default"):
        # Directions:
        if(command == "forward"):
            GPIO.output(self.in_1_1, GPIO.HIGH)
            GPIO.output(self.in_1_2, GPIO.LOW)
            GPIO.output(self.in_2_1, GPIO.HIGH)
            GPIO.output(self.in_2_2, GPIO.LOW)
        elif(command == "left"):
            GPIO.output(self.in_1_1, GPIO.LOW)
            GPIO.output(self.in_1_2, GPIO.LOW)
            GPIO.output(self.in_2_1, GPIO.HIGH)
            GPIO.output(self.in_2_2, GPIO.LOW)       
        elif(command == "right"):
            GPIO.output(self.in_1_1, GPIO.HIGH)
            GPIO.output(self.in_1_2, GPIO.LOW)
            GPIO.output(self.in_2_1, GPIO.LOW)
            GPIO.output(self.in_2_2, GPIO.LOW)
        elif(command == "turn"):
            GPIO.output(self.in_1_1, GPIO.LOW)
            GPIO.output(self.in_1_2, GPIO.HIGH)
            GPIO.output(self.in_2_1, GPIO.HIGH)
            GPIO.output(self.in_2_2, GPIO.LOW)
        elif(command == "stop"):
            GPIO.output(self.in_1_1, GPIO.LOW)
            GPIO.output(self.in_1_2, GPIO.LOW)
            GPIO.output(self.in_2_1, GPIO.LOW)
            GPIO.output(self.in_2_2, GPIO.LOW)
        # Speed:
        if(speed == "low"):
            self.s_1.ChangeDutyCycle(25)
            self.s_2.ChangeDutyCycle(25)
        elif(speed == "normal"):
            self.s_1.ChangeDutyCycle(50)
            self.s_2.ChangeDutyCycle(50)                
        elif(speed == "moderate"):
            self.s_1.ChangeDutyCycle(75)
            self.s_2.ChangeDutyCycle(75)                
        elif(speed == "high"):
            self.s_1.ChangeDutyCycle(90)
            self.s_2.ChangeDutyCycle(90)       
        

# Define a new class object named 'robot':
robot = Litter_Detection_Robot(17, 27, 22, 10, 9, 11)
robot.robot_chassis_init()

while True:
    robot.get_data_from_LIDAR()